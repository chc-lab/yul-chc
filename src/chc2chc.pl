% ==============================================================================
%
%          FILE: chc2chc.pl
%
%   DESCRIPTION: translator from CHC to CHC
%         USAGE: see transform
%
%  REQUIREMENTS: types.pl
%       LICENSE: See the file LICENSE.txt for license and copyright details.
% ==============================================================================

:- use_module(types).

:- multifile map2/3.
:- discontiguous map2/3.


%%%%  map2mapnum: adds numbers to clauses and atoms
%% TODO: check if ff :- ... query is numbered correctly

map2(mapnum,Cls,Prop) :-
  use_module(solver('clpBQRA')),
  write('% Automatically generated by map2mapnum'), nl, nl,

	findall(P, (types:user_defined_pred(P)), Preds),
	findall(M, (types:functor_mode(M)), Modes),

% type constructors  
	findall(DTName, types:user_defined_type(DTName), DTNames),
	types:show_datatypes(DTNames), nl,
  
  maplist(pred_addargs(Prop),Preds,Preds1),
  show_signatures(Preds1), nl,
  maplist(mode_addargs,Modes,Modes1),
  show_modes(Modes1), nl,
  
  maplist(clause_to_canonical_form,Cls,Cls1),
 	length(Cls,Len),

 	numlist(1,Len,ClNums),
  maplist(clause_add_clause_num(Prop),ClNums,Cls1,Cls2),	
  
  maplist(clause_add_atom_num(Prop),Cls2,Cls3),

  show_cls(Cls3).


pred_addargs(Prop,A,A1) :-
	A =.. [F|Args],
	% ignore query predicate Prop
	( F\==Prop ->
	    A1 =.. [F,int,int|Args] 
	  ;  
	    A1=A
	).

mode_addargs(A,A1) :-
	A =.. [F|Args],
	A1 =.. [F,in,out|Args].

% TODO: change name? move to io.pl ?
clause_to_canonical_form((H,B),(H,bd(C,BLAtoms))) :-
	conj_to_list(B,BL),
	constr(BL,C,BLAtoms).	

clause_add_atom_num(Prop,(H,bd(C,B)),(H1,bd(C2,RB2))) :-
	add_atom_num(Prop,[H|B],[H1|B1]),
	constr(B1,C1,B2),
	% constr/3 reverses the order of atoms
	reverse(B2,RB2),
	constr_and(C,C1,C2).	

add_atom_num(Prop,B,B1) :- 
	add_atom_num(Prop,0,B,B1).

add_atom_num(_,_,[],[]).
add_atom_num(Prop,X,[A|As],[A1|A1s]) :-
	A =.. [F|Args],
	F\==Prop, % ignore query predicate Prop
	% types:user_defined_pred(FA),
	% FA =.. [F|_],
	!,
 % symbolic version, needs to add constraint Pos=Y after A1:  
 % add_atom_num(Prop,X,[A|As],[A1,Pos=Y|A1s]) :-
 %	(X>0 -> Y=X; Y=Pos), % add dummy constraint if X=0   % symbolic version

	(X>0 -> Pos=X; true), %  ground version
	X1 is X+1, 	
	A1 =.. [F,Pos|Args],
	add_atom_num(Prop,X1,As,A1s).
add_atom_num(Prop,X,[A|As],[A|A1s]) :-
	add_atom_num(Prop,X,As,A1s).	


clause_add_clause_num(Prop,N,(H,bd(C,B)),(H1,bd(C2,B2))) :-
	H =.. [F|Args],
  % ignore query predicate Prop
	( F\==Prop ->  
	    ( H1 =.. [F,Pos|Args],
	      % constr([Pos=N],C1,[]), constr_and(C,C1,C2) % symbolic version, adds a contraint
	      Pos=N, C2=C     % ground version
	    )
	  ;  
	    (H1=H, C2=C)
	),
	
	maplist(atom_add_clause_num,B,B2).


% adds an extra argument 
atom_add_clause_num(A,A1) :-
	A =.. [F|Args],
	A1 =.. [F,_|Args].





