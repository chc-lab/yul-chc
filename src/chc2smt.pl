% ==============================================================================
%
%          FILE: chc2smt.pl
%
%   DESCRIPTION: translator form CHC to SMT-LIBv2
%         USAGE: see transform
%
%  REQUIREMENTS: types.pl
%       LICENSE: See the file LICENSE.txt for license and copyright details.
% ==============================================================================

:- use_module(types).

:- multifile map2/2.
:- discontiguous map2/2.

:- dynamic impl_spaces/0.
body_spaces :- impl_spaces, write('  ').
head_spaces :- impl_spaces, write('  ').

:- dynamic smt_version/1.


% SEMANTICS: translate a prolog type into an SMT-LIBv2 type
% (represented as an atom)
smt_type(PType,SMTType) :-
  smt_type_chars(PType,SMTTypeChars),
  atom_chars(SMTType,SMTTypeChars).

% SEMANTICS: translate a prolog type into an SMT-LIBv2 type
% (represented as list of characters)
smt_type_chars(PType,[]) :-
  functor(PType,[],0),
  !.
% basic type (e.g., int)
smt_type_chars(PType,SMTType) :-
  basic_type(PType,SMTType),
  !.
% variables occurring in type definitions (e.g., tree(T) ---> ...)
smt_type_chars(PType,SMTType) :-
  functor(PType,'$VAR',1),
  !,
  write_to_chars(PType,SMTType).
% type definition (right hand side of type definition)
smt_type_chars(PType,SMTType) :-
  functor(PType,'[|]',2),
  !,
  arg(1,PType,PType1),
  arg(2,PType,PType2),
  smt_type_chars(PType1,SMTType1),
  smt_type_chars(PType2,SMTType2),
  append([32|SMTType1],SMTType2,SMTType).
% compound datatypes
smt_type_chars(PType,SMTType) :-
  PType =.. [Name|PTypes],
  !,
  first_upper_chars(Name,SMTName),
  smt_type_chars(PTypes,SMTTypes),
  % append([40|SMTName],SMTTypes,SMTTypes3),  % add (
  % append(SMTTypes3,[41],SMTType),   % add )
  append(SMTName,SMTTypes,SMTType) .
% unknown type
smt_type_chars(T,_) :-
  throw(cannot_translate_type(T)).

% HORN basic types
:- dynamic basic_type/2.
% int  -> Int
basic_type(int, [73,110,116]).
% real -> Real
basic_type(real,[82,101,97,108]).
% bool -> Bool
basic_type(bool,[66,111,111,108]).
% TODO: Reynolds & Kuncak  cvc4
basic_type(treeofint,T) :-
  first_upper(treeofint,T1),
  atom_chars(T1,T).
% array(Type) -> Array Int Type
basic_type(array(Type),TypeChars) :-
  basic_type(Type,Chars), atom_chars(BT,Chars),
  atom_concat('(Array Int ',BT,T1), atom_concat(T1,')',T2),
  atom_chars(T2,TypeChars).
  %TypeChars = [40,65,114,114,97,121, 32, 73,110,116, 32|Chars]. % Array Int Chars

% ==============================================================================
%                                MAP2SMT
% ==============================================================================
map2(smt,Cls) :-
  assert(smt_version(smtv2)),
  write('; Automatically generated by map2smt'), nl, nl,
  map2_smt(Cls).

map2(cvc,Cls) :-
  assert(smt_version(cvc4)),
  write('; Automatically generated by map2cvc'), nl, nl,
  map2_smt(Cls).

map2_smt(Cls) :-
  cls_to_hdbdpair(Cls,Cls1),
  assert((impl_spaces :- write('    '))),
  smt_rules(Cls1,Rules,UsedTypes),
  sortByDependency(UsedTypes,SUsedTypes),
  % 1) declarations
  % 1.1) set-logic
  (smt_version(cvc4) ->
    write('(set-logic ALL_SUPPORTED)')
  ;
    write('(set-logic HORN)')
  ),
  nl, nl, assert(max_sel_num(0)),
  % 1.2) declare-datatypes for built-in adt
  write_builtin_adts_declarations(SUsedTypes), nl,
  % 1.3) declare-datatypes for user defined adt
  write_userdef_adts_declarations, nl,
  % 1.4) declare-fun
  write_pred_declarations(fun),
  % 2) clauses
  write_smt_rules(Rules), nl,
  % 3) queries
  write_queries,
  write('(check-sat)'), nl.

% ------------------------------------------------------------------------------
sortByDependency(TypesI,[Type1|STypes]) :-
  select(Type1,TypesI,Types2),
  select(Type2,Types2,TypesR),
  contains_var(Type1,Type2),
  sortByDependency([Type2|TypesR],STypes).
sortByDependency(Types,Types).

% SEMANTICS: write declarations of USER DEFINED algebraic datatypes
write_userdef_adts_declarations :-
  user_defined_type(DTName),
  numbervars(DTName,0,_),
  DTName =.. [Func|Args],

  %%% FF: disallow  user defined adts with  parametric type
  Args == [],
  %
  write('(declare-datatypes ('),
  first_upper(Func,DTFuncUp), % Datatype name
  maplist(write_type_smtv2,[DTFuncUp]),
  write(')'), nl, write('(('),
  maplist(write_type_smtcvc4,Args),
  %
  type_constructors_def(DTName,DTDef),
  write_adts_declaration(DTDef,DTName,DTFuncUp),
  write(')))'), nl,
  fail.
write_userdef_adts_declarations :- nl.

% SEMANTICS: write declarations of BUILTIN algebraic datatypes
write_builtin_adts_declarations([]).
write_builtin_adts_declarations([Type|Adts]) :-
  memberchk(Type,['int','real','bool']),
  write_builtin_adts_declarations(Adts).
% lists
write_builtin_adts_declarations([list(Type)|Adts]) :-
% avoid duplicate type declaration
  basic_type(list(Type),_),
  !,
  write_builtin_adts_declarations(Adts).
write_builtin_adts_declarations([list(Type)|Adts]) :-
  smt_type_chars(Type,TypeCodes),
  !,
  delete_chk([40,41,32],TypeCodes,TypeCodes1),
  atom_codes(SMTType,TypeCodes1),
  ListOfTChars = [108,105,115,116,79,102|TypeCodes1], % listOfType
  atom_codes(ListOfT,ListOfTChars),
  %
  write('(declare-datatypes ('),
  write_type_smtv2(ListOfT),
  write(')'), nl,  write('(('),
  write_type_smtcvc4(ListOfT),
  %
  write('(cons'), write(ListOfT), write(' '),
  write('(head'), write(ListOfT), write(' '), write(SMTType), write(') '),
  write('(tail'), write(ListOfT), write(' '), write(ListOfT), write(')) '),
  write('(nil'),  write(ListOfT), write(')'),
  write(')))'), nl,

  assert(basic_type(list(Type),ListOfTChars)), % add ListOfType to built-ins
  write_builtin_adts_declarations(Adts).
% pairs
write_builtin_adts_declarations([pair(Type1,Type2)|Adts]) :-
  smt_type_chars(Type1,TypeCodes1),
  smt_type_chars(Type2,TypeCodes2),
  append(TypeCodes1,TypeCodes2,TypeCodes),
  PairOfType1Type2Chars = [112,97,105,114,79,102|TypeCodes], % pairOfType1Type2
  atom_codes(PairOfT,PairOfType1Type2Chars),
  %
  write('(declare-datatypes ('),
  write_type_smtv2(PairOfT),
  write(')'), nl,
  write_type_smtcvc4(PairOfT),
  %
  write('  (((pair'), write(PairOfT), write(' '),
  write('(fst'), write(PairOfT), write(' '),
  smt_type(Type1,SMTType1), write(SMTType1), write(') '),
  write('(snd'), write(PairOfT), write(' '),
  smt_type(Type2,SMTType2), write(SMTType2), write(')) '),
  write(')))'), nl,
  % add pairOfType1Type2 to built-ins
  assert(basic_type(pair(Type1,Type2),PairOfType1Type2Chars)),
  write_builtin_adts_declarations(Adts).
% trees
write_builtin_adts_declarations([tree(Type)|Adts]) :-
   smt_type_chars(Type,TypeCodes),
  !,
  delete_chk([40,41,32],TypeCodes,TypeCodes1),
  atom_codes(SMTType,TypeCodes1),
  atom_codes(treeOf,TreeOfCodes),
  append(TreeOfCodes,TypeCodes1,TreeOfTChars),
  atom_codes(TreeOfT,TreeOfTChars),
  %
  write('(declare-datatypes ('),
  write_type_smtv2(TreeOfT),
  write(')'), nl, write('(('),
  write_type_smtcvc4(TreeOfT),
  %
  write('(node'), write(TreeOfT), write(' '),
  write('(data'), write(TreeOfT), write(' '), write(SMTType), write(') '),
  write('(left'), write(TreeOfT), write(' '), write(TreeOfT), write(') '),
  write('(right'), write(TreeOfT), write(' '), write(TreeOfT), write(')) '),
  write('(leaf'),  write(TreeOfT), write(')'),
  write(')))'), nl,
  assert(basic_type(tree(Type),TreeOfTChars)), % add TreeOfType to built-ins
  write_builtin_adts_declarations(Adts).
% heaps
write_builtin_adts_declarations([heap(Type)|Adts]) :-
  smt_type_chars(Type,TypeCodes),
  !,
  delete_chk([40,41,32],TypeCodes,TypeCodes1),
  atom_codes(SMTType,TypeCodes1),
  atom_codes(heapOf,HeapOfCodes),
  append(HeapOfCodes,TypeCodes1,HeapOfTChars),
  atom_codes(HeapOfT,HeapOfTChars),
  %
  write('(declare-datatypes ('),
  write_type_smtv2(HeapOfT),
  write(')'), nl, write('(('),
  write_type_smtcvc4(HeapOfT),
  %
  write('(heap'), write(HeapOfT), write(' '),
  write('(rk'), write(HeapOfT), write(' '), write(SMTType), write(') '),
  write('(value'), write(HeapOfT), write(' '), write(SMTType), write(') '),
  write('(left'), write(HeapOfT), write(' '), write(HeapOfT), write(') '),
  write('(right'), write(HeapOfT), write(' '), write(HeapOfT), write(')) '),
  write('(hleaf'),  write(HeapOfT), write(')'),
  write(')))'), nl,
  assert(basic_type(heap(Type),HeapOfTChars)), % add HeapOfType to built-ins
  write_builtin_adts_declarations(Adts).
% queues
write_builtin_adts_declarations([queue(Type)|Adts]) :-
  % ensure list(Type) is declared but avoid duplicate type declaration
  ( basic_type(list(Type),_) -> true ; write_builtin_adts_declarations([list(Type)])),
  smt_type_chars(Type,TypeCodes),
  !,
  delete_chk([40,41,32],TypeCodes,TypeCodes1),
  % atom_codes(SMTType,TypeCodes1), % Singleton variables: [SMTType]
  atom_codes(queueOf,QueueOfCodes),
  append(QueueOfCodes,TypeCodes1,QueueOfTChars),
  atom_codes(QueueOfT,QueueOfTChars),
  atom_codes(listOf,ListOfCodes),
  append(ListOfCodes,TypeCodes1,ListOfTChars),
  atom_codes(ListOfT,ListOfTChars),
  %
  write('(declare-datatypes ('),
  write_type_smtv2(QueueOfT),
  write(')'), nl, write('(('),
  write_type_smtcvc4(QueueOfT),
  %
  write('(queue'), write(QueueOfT), write(' '),
  write('(front'), write(QueueOfT), write(' '), write(ListOfT), write(') '),
  write('(back'), write(QueueOfT), write(' '), write(ListOfT), write(')) '),
  write(')))'), nl,
  assert(basic_type(queue(Type),QueueOfTChars)), % add QueueOfType to built-ins
  write_builtin_adts_declarations(Adts).
%
write_builtin_adts_declarations([_Type|Adts]) :-
  write_builtin_adts_declarations(Adts).

%
write_type_smtv2(Type) :-
  (smt_version(smtv2) ->
    (write('('), write(Type), write(' 0) '))
  ;
    true
  ).
%
write_type_smtcvc4(Type) :-
  (smt_version(cvc4) ->
    (write(Type), write(' '))
  ;
    true
  ).

% SEMANTICS: write a list of terms
write_list([]).
write_list([E|Es]) :-
  write(E),
  write_list(Es).

% SEMANTICS: write the definition of the Datatype
write_adts_declaration([],_DTName,_DTFuncUp).
write_adts_declaration([C|Cs],DTName,DTFuncUp) :-
  C =.. [Name|[]],
  !,
%  write(' '), write(Name),
  write('('), write(Name), write(')'),
  write_adts_declaration(Cs,DTName,DTFuncUp).
write_adts_declaration([C|Cs],DTName,DTFuncUp) :-
  C =.. [Name|Args],
  write(' ('), write(Name),
  substitute(DTName,Args,DTFuncUp,Args1),
  retract(max_sel_num(N)),
  write_constructor_args(N,Args1,M),
  assert(max_sel_num(M)),
  write(')'),
  write_adts_declaration(Cs,DTName,DTFuncUp).

% SEMANTICS: write the constructors of the defined algebraic datatypes
write_constructor_args(N,[],N).
%
write_constructor_args(N,[A|As],M) :-
  atom_concat(' (sel',N,S), write(S),
  ( is_type(A) -> smt_type(A,B) ; A=B ), N1 is N+1, write(' '),
  write(B),
  write(')'),
  write_constructor_args(N1,As,M).

% ------------------------------------------------------------------------------
% SEMANTICS: write SMT-LIBv2 declarations of predicates
write_pred_declarations(fun) :-
  types:user_defined_pred(Pred),
  functor(Pred,F,_),
  write('(declare-fun '),
  (types:functor_fun(F,_,_,_,_) ->
    (
      write(F), write(' '),
      types:functor_signature_io(F,InTypes,OutTypes),
      write('('),
      write_smt_pred_types(InTypes),
      write(') '),

      % if single output
      ( OutTypes = [_] ->
        ( write('('), write_smt_pred_types(OutTypes), write(')') )
      ;
        % write output type
        (types:functor_output_type_name(F,TName), write_smt_pred_type(TName))
      ),
      write(')')
    )
  ;
    (write_smt_pred(Pred), write(' Bool)'))
  ),
  nl,
  fail.
%
write_pred_declarations(rel) :-
  types:user_defined_pred(Pred),
  write('(declare-rel '), write_smt_pred(Pred), write(')'), nl,
  fail.
%
write_pred_declarations(_Dl) :-
  nl.

% SEMANTICS: write predicate name with types
write_smt_pred(Pred) :-
  Pred =.. [Func|Types],
  write(Func), write(' '), write('('),
  write_smt_pred_types(Types), write(')').

% SEMANTICS: write a list of types
write_smt_pred_types([]).
write_smt_pred_types([A]) :-
  write_smt_pred_type(A),
  !.
write_smt_pred_types([A|As]) :-
  write_smt_pred_type(A), write(' '),
  write_smt_pred_types(As).

% SEMANTICS: translate prolog type into the SMT-LIBv2 type and write it
write_smt_pred_type(A) :-
  smt_type(A,B), write(B).

% ------------------------------------------------------------------------------
% MODE: smt_rules(+Cls,-Smt,-UsedTypes)
% SEMANTICS: convert CHC to SMT-LIBv2 rules
% Cls is a list of chc, Smt is a list of pairs of the form (Vars,Rule),
% where Vars is the list of variables occurring in Rule, and UsedTypes
% is the list of types occurring in Smt
smt_rules(Cls,Rules,UsedTypes) :-
  smt_rules(Cls,Rules,[],UsedTypes).
%
smt_rules([],[],UsedTypes,UsedTypes).
smt_rules([Cl|Cls],[(Vars,Rule)|Rules],UsedTypesIn,UsedTypesOut) :-
  smt_rule(Cl,Rule,Vars),
  numbervars(Vars,0,_),
  used_types(Vars,UsedTypesIn,UsedTypesIn1),
  smt_rules(Cls,Rules,UsedTypesIn1,UsedTypesOut).
%
used_types([],UsedTypes,UsedTypes).
used_types([_Var::Type|TypedVars],UsedTypesIn,UsedTypesOut) :-
  memberchk(Type,UsedTypesIn),
  used_types(TypedVars,UsedTypesIn,UsedTypesOut).
used_types([_Var::Type|TypedVars],UsedTypesIn,UsedTypesOut) :-
  used_types(TypedVars,[Type|UsedTypesIn],UsedTypesOut).

%
smt_rule(Cl,Rl,Vars) :-
  Cl = (H,T),
  conj_to_list(T,TLst), iu(TLst,I,U), append(I,U,B),
  catch(
    types:typed_term([H|B],TT,Vars), % (*)
    E,
    map_error(write(E))
  ),
  TT = [TH|TB]::list(bool),
  Rl = (TH,TB).
% (*) the types of builtin predicates are known, use this knowledge reduces the
% nondeterminism in inferring the types of variables occurring in the constraint
iu([],[],[]).
% disequality/inequality constraints: KEEP
iu([T|Ts],[T|Bs],U) :-
  nonvar(T),
  functor(T,P,2),
  memberchk(P, ['<','>','=<','>=','=\\=']),
  !,
  iu(Ts,Bs,U).
% equality constraints: if it is between variables, then REMOVE else KEEP
iu([T|Ts],Bs,U) :-
  nonvar(T),
  ( T = (T1=T2) ; T = (T1=:=T2) ),
  !,
  ( ( var(T1), var(T2) ) ->
    ( call(T1=T2), Bs = Bs1 )
  ;
    Bs = [T|Bs1]
  ),
  iu(Ts,Bs1,U).
% write constraints: KEEP
iu([T|Ts],[read(A,I,V)|Bs],U) :-
  nonvar(T),
  T = read(A,I,V),
  !,
  iu(Ts,Bs,U).
% write constraints: KEEP
iu([T|Ts],[write(A,I,V,B)|Bs],U) :-
  nonvar(T),
  T = write(A,I,V,B),
  !,
  iu(Ts,Bs,U).
% val constraints: REMOVE
iu([T|Ts],Bs,U) :-
  nonvar(T),
  T = val(_,_),
  !,
  iu(Ts,Bs,U).
% uninterpreted predicates: KEEP
iu([T|Ts],Bs,[T|Us]) :-
  iu(Ts,Bs,Us).


% SEMANTICS: write SMT-LIBv2 rules
write_smt_rules([]).
% fact
write_smt_rules([Rule|Rules]) :-
  Rule=([],Cl),
  !,
  write('(assert'), nl,
  write_smt_rule(Cl), nl,
  write(')'),        nl,
  write_smt_rules(Rules).
% implication
write_smt_rules([Rule|Rules]) :-
  write('(assert'), nl,
  Rule=(Vars,Cl),
  write('  (forall ( '), smt_vars(Vars), write(')'), nl,
  write_smt_rule(Cl), nl,
  write('  )'), nl,
  write(')'),   nl,
  write_smt_rules(Rules).

% SEMANTICS: write a list of variables with the corresponding types
smt_vars([]).
%
smt_vars([Var::Type|VarTypes]) :-
  write('('),
  write_stm_var(Var,Type),
  write(') '),
  smt_vars(VarTypes).

% SEMANTICS: write a variable with its type
write_stm_var(Var,Type) :-
  write(Var), write(' '),
  smt_type(Type,Type1),
  write(Type1).

% SEMANTICS: write the SMT-LIBv2 rule
% fact
write_smt_rule(Cl) :-
  Cl=(H,[]::list(bool)),
  !,
  impl_spaces,
  term2smt(H).
% implication of the form H :- B.
write_smt_rule(Cl) :-
  Cl=(H,[B|[]::list(bool)]::list(bool)),
  !,
  impl_spaces, write('(=>'), nl,
  body_spaces, term2smt(B), nl,
  head_spaces, term2smt(H), nl,
  impl_spaces, write(')').
% implication of the form H :- B1,...,Bn with n>=2
write_smt_rule(Cl) :-
  Cl=(H,B),
  impl_spaces, write('(=>'), nl,
  body_spaces, write('(and'), termList2smt(B), nl, write('      )'), nl,
  head_spaces, term2smt(H), nl,
  impl_spaces, write(')').

% SEMANTICS: convert a list of terms to SMT-LIBv2 (write_smt_rule utility pred.)
termList2smt([]::list(bool)).
termList2smt([H|T]::list(bool)) :-
  nl,
  write('        '),
  term2smt(H),
  termList2smt(T).


term2smt_suffix(Y,X) :-
  term2smt(X),
  write(Y).


% SEMANTICS: convert a term to SMT-LIBv2
:- discontiguous term2smt/1.
% numbers ----------------------------------------------------------------------
term2smt(Term::Type) :-
  number(Term),
  ( Type == int ; Type == real ),
  !,
  ( Term < 0 ->
    ( N1 is -1 * Term, write('(- '), write(N1), write(')') )
  ;
    write(Term)
  ).
% booleans ---------------------------------------------------------------------
term2smt(Term::bool) :-
  number(Term),
  ( Term == 1 ->
    write(true)
  ;
    ( Term == 0 ->
      write(false)
    ;
      fail
    )
  ).
% binary relations -------------------------------------------------------------
term2smt(Term::bool) :-
  Term =.. [Pred,Lhs::Type,Rhs::Type],
  memberchk(Pred,['=','=:=','=<','>=','>','<','-','/']),
  !,
  clp_to_smt(Type,Pred,Pred1),
  write('('), write(Pred1), write(' '),
  term2smt(Lhs::Type), write(' '), term2smt(Rhs::Type),
  write(')').
term2smt(Term::bool) :-
  Term =.. [Pred,Lhs::Type,Rhs::Type],
  memberchk(Pred,['+','*']),
  !,
  clp_to_smt(Type,Pred,Pred1),
  write('('), write(Pred1), write(' '),
  term2smt(Lhs::Type), write(' '), term2smt(Rhs::Type),
  write(')').
% =\=, #
term2smt(Term::bool) :-
  Term =.. [Pred,Lhs,Rhs],
  memberchk(Pred,['=\\=','#']),
  !,
  NewT=..[=,Lhs,Rhs],
  write('(not '), term2smt(NewT::bool), write(')').
% boolean connectives ----------------------------------------------------------
term2smt(Term::bool) :-
  nonvar(Term),
  Term =.. [Op, Arg],
  memberchk(Op, ['not', '~']), % <--- Gestiamo diversi modi di scrivere "not"
  !,
  write('(not '), term2smt(Arg), write(')').



%term2smt(Term::bool) :-
 % Term =.. ['not','~',Arg],
 % !,
 % write('(not '), term2smt(Arg), write(')').
term2smt(Term::bool) :-
  Term =.. [Pred,Lhs,Rhs],
  memberchk(Pred,['or','v',';']),
  !,
  write('(or '), term2smt(Lhs), write(' '), term2smt(Rhs), write(')').
term2smt(Term::bool) :-
  Term =.. [Pred,Lhs,Rhs],
  memberchk(Pred,['and','&',',']),
  !,
  write('(and '), term2smt(Lhs), write(' '), term2smt(Rhs), write(')').
term2smt(Term::bool) :-
  Term =.. ['=>',Lhs,Rhs],
  !,
  write('(=> '), term2smt(Lhs), write(' '), term2smt(Rhs), write(')').
% constraint ignored furing transformation -------------------------------------
term2smt(Term::bool) :-
  Term = constr(Arg),
  !,
  term2smt(Arg).
% variables --------------------------------------------------------------------
term2smt(Term::_Type) :-
  Term=..[-,Var], Var='$VAR'(_),
  !,
  write('(- '), write(Var), write(')').
%
term2smt(Term::_Type) :-
  Term='$VAR'(_),
  !,
  write(Term).
% array constraints ------------------------------------------------------------
% read/3
term2smt(Term::bool) :-
  Term =.. [read,(A::array(T1),_)::pair(array(T1),T2),I::T1,V::T2],
  write('(= (select '),
  write(A), write(' '),
  write(I), write(') '),
  write(V),
  write(')').
% write/4
term2smt(Term::bool) :-
  Term =.. [write,(A1::array(T1),_)::pair(array(T1),T2),
                  I::T1,V::T2,
                  (A2::array(T1),_)::pair(array(T1),T2)],
  write('(= (store '),
  write(A1), write(' '),
  write(I),  write(' '),
  write(V),  write(') '),
  write(A2),
  write(')').
% lists ------------------------------------------------------------------------
% []
term2smt([]::list(Type)) :-
  !,
  smt_type(list(Type),SMTType),
  write('nil'), write(SMTType).
  % each list has its own nil symbol to avoid the use of
  % qualified expression (as <symbol> <sort>) to disumbiguate nil
% [H|T]
term2smt(Term::list(Type)) :-
  Term =.. [Func|Args],
  ( Func == '.'; Func == '[|]' ),
  !,
  basic_type(list(Type),ListOfTChars), atom_chars(ListOfT,ListOfTChars),
  smt_type_chars(Type,TypeChars), append(TypeChars,[41],Chars),
  % Naming convention for list(Type)
  % muZ format: List Type
  % SMT-LIB format: ListOfType (with no parameters)
  % http://cvc4.cs.stanford.edu/wiki/Datatypes
  ( [40,76,105,115,116,32|Chars] == ListOfTChars ->
    Cons=insert  % muZ format
  ;
    Cons=cons   % SMT-LIB format
  ),
  atom_concat(Cons,ListOfT,CListOfT),
  apply_Args(CListOfT,Args).
% pairs ------------------------------------------------------------------------
term2smt(Term::pair(Type1,Type2)) :-
  smt_type(pair(Type1,Type2),SMTType),
  Term = (Term1::Type1,Term2::Type2),
  write('(pair'), write(SMTType), write(' '),
  term2smt(Term1::Type1), write(' '),
  term2smt(Term2::Type2),
  write(')').
% FF
% trees ------------------------------------------------------------------------
term2smt(leaf::tree(Type)) :-
  !,
  smt_type(tree(Type),SMTType),
  write('leaf'), write(SMTType).
term2smt(node(Data,Left,Right)::tree(Type)) :-
  !,
  smt_type_chars(Type,TypeCodes),
  delete_chk([40,41,32],TypeCodes,TypeCodes1),
  % atom_codes(SMTType,TypeCodes1), % Singleton variables: [SMTType]
  atom_codes(treeOf,TreeOfCodes),
  append(TreeOfCodes,TypeCodes1,TreeOfTChars),
  atom_codes(TreeOfT,TreeOfTChars),
  write('(node'), write(TreeOfT), write(' '),
  term2smt(Data), write(' '),
  term2smt(Left), write(' '), term2smt(Right), write(') ').
% heaps
term2smt(hleaf::heap(Type)) :-
  !,
  smt_type(heap(Type),SMTType),
  write('hleaf'), write(SMTType).
term2smt(heap(Rk,Value,Left,Right)::heap(Type)) :-
  !,
  smt_type_chars(Type,TypeCodes),
  delete_chk([40,41,32],TypeCodes,TypeCodes1),
  % atom_codes(SMTType,TypeCodes1), % Singleton variables: [SMTType]
  atom_codes(heapOf,HeapOfCodes),
  append(HeapOfCodes,TypeCodes1,HeapOfTChars),
  atom_codes(HeapOfT,HeapOfTChars),
  write('(heap'), write(HeapOfT), write(' '),
  term2smt(Rk), write(' '), term2smt(Value), write(' '),
  term2smt(Left), write(' '), term2smt(Right), write(') ').
% queues
term2smt(queue(Front,Back)::queue(Type)) :-
  !,
  smt_type_chars(Type,TypeCodes),
  delete_chk([40,41,32],TypeCodes,TypeCodes1),
  % atom_codes(SMTType,TypeCodes1), % Singleton variables: [SMTType]
  atom_codes(queueOf,QueueOfCodes),
  append(QueueOfCodes,TypeCodes1,QueueOfTChars),
  atom_codes(QueueOfT,QueueOfTChars),
  write('(queue'), write(QueueOfT), write(' '),
  term2smt(Front), write(' '), term2smt(Back), write(') ').
% if-then-else -----------------------------------------------------------------
term2smt(Term::bool) :-
  Term =.. [ite,Cond,Then,Else],
  !,
  write('(ite '),
  term2smt(Cond), write(' '), term2smt(Then), write(' '), term2smt(Else),
  write(')').
% atomic formulae and functions ------------------------------------------------
term2smt(Term::_Type) :-
  Term =.. [Func|Args],
  !,
  apply_Args(Func,Args).
% propositional atomic formula -------------------------------------------------
apply_Args(Pred,[]) :-
  !,
  write(Pred).
% first order atomic formula ---------------------------------------------------
apply_Args(Pred,Args) :-
  types:functor_fun(Pred,_,A,In,Out),
  !,
  A1 =.. [Pred|Args],
  A1 = A,
  write('(= '),
  length(Out,OL),
  (OL > 1 -> (types:functor_output_type_name(Pred,TName), write('('), write(TName), write(' ') ) ; true),
  maplist(term2smt_suffix(' '),Out),
  (OL > 1 -> write(')') ; true),
  write(' '),
  apply_Args2(Pred,In),
  write(')').

apply_Args(Pred,Args) :-
  apply_Args2(Pred,Args).

apply_Args2(Pred,Args) :-
  write('('),
  write(Pred),
  write_ArgsList(Args),
  write(')').
%
write_ArgsList([]).
write_ArgsList([H|T]) :-
  write(' '),
  term2smt(H),
  write_ArgsList(T).

% clp relation -----------------------------------------------------------------
clp_to_smt(_Type,R, S) :- R=='=:=', !, S='='.
clp_to_smt(_Type,R, S) :- R=='=<',  !, S='<='.
clp_to_smt(Type, R, S) :- R=='*', Type == bool, !, S='and'.
clp_to_smt(Type, R, S) :- R=='+', Type == bool, !, S='or'.
clp_to_smt(_Type, R, R).

write_queries :-
  % findall(PPred, vs(prop(PPred)), PPreds),  % prop
  % TODO: change transform.pl: assert prop/1 into the database (see udf)
  findall(QPred, vs(query(QPred/_)), Preds), % query
  write_queries_aux(Preds).

write_queries_aux([]).
write_queries_aux([Pred|Preds]) :-
  write('(assert (not '), write(Pred), write('))'), nl,
  write_queries_aux(Preds).


% ==============================================================================
%                             MAP2Z3 - Z3 solver
% ==============================================================================
map2(z3,Cls) :-
  write('; Automatically generated by map2z3'), nl, nl,
  assert((impl_spaces :- write('  '))),
  % list(Type) -> List Type  where Type is either Int or Real
  assert( basic_type(list(int), [40,76,105,115,116,32,73,110,116,41])    ),
  assert( basic_type(list(real),[40,76,105,115,116,32,82,101,97,108,41]) ),
  %
  SymTabIn=(numbervars_index(0),[]),
  cls_to_hdbdpair(Cls,Cls1),
  muz3_rules(Cls1,SymTabIn,Rules,SymTabOut),
  SymTabOut=(numbervars_index(_),Vars), assert(max_sel_num(0)),
  % 1) declarations
  % 1.2) declare-datatypes for user defined adt
  write_userdef_adts_declarations,
  % 1.3) declare-rel
  write_pred_declarations(rel),
  % 1.2) declare-var
  write_vars_declarations(Vars),
  % 2) clauses
  write_muz3_rules(Rules), nl,
  % 3) query
  vs(query(QP/_)),
  write('(query '), write(QP), write(')').

% SEMANTICS: convert CHC to SMT-LIBv2 rules
muz3_rules([],SymTab,[],SymTab).
%
muz3_rules([Cl|Cls],SymTabIn,[Rule|Rules],SymTabOut) :-
  smt_rule(Cl,Rule,Vars),
  muz3_numbervars(Vars,SymTabIn,SymTabIn, SymTabIn1),
  muz3_rules(Cls,SymTabIn1,Rules,SymTabOut).

% SEMANTICS: collect variables occurring in rules by using a symbol table
% The symbol table is a pair of the form (NumIdx,Syms) where: NumIdx is the
% number that should be used with numbervars to get the next variable and
% Syms is a list of pairs (Type,Vars) consisting of a list of variables
% Vars (terms of the form '$VAR'(_)) of type Type.
muz3_numbervars([],_CurrSymTabIn,NewSymTabIn, NewSymTabOut) :-
  NewSymTabIn=NewSymTabOut.
% get variable definition from the symbol table
muz3_numbervars([Var|Vars],CurrSymTabIn,NewSymTabIn, NewSymTabOut) :-
  var_definition(Var,CurrSymTabIn,CurrSymTabIn1), !,
  muz3_numbervars(Vars,CurrSymTabIn1,NewSymTabIn, NewSymTabOut).
% add new variable definition to the symbol table
muz3_numbervars([Var|Vars],CurrSymTabIn,NewSymTabIn, NewSymTabOut) :-
  new_var_definition(Var,NewSymTabIn,NewSymTabIn1),
  muz3_numbervars(Vars,CurrSymTabIn,NewSymTabIn1, NewSymTabOut).

% SEMANTICS: get variable definition from the symbol table
var_definition(Var::Type,(NumIdx,SymsIn),(NumIdx,SymsOut)) :-
  Def1=(Type,AvVars), % AvVars is the list of available variables of type Type
  select(Def1,SymsIn,RestSyms),
  select(Var,AvVars,RestAvVars),
  Def2=(Type,RestAvVars), % RestAvVars is the new list of available variables
  SymsOut=[Def2|RestSyms].

% SEMANTICS: add new variable definition to the symbol table
new_var_definition(Var::Type,(NumIdxIn,SymsIn),(NumIdxOut,SymsOut)) :-
  NumIdxIn=numbervars_index(N),
  numbervars(Var,N,M), % Var is a new variable
  Def=(Type,AvVarsIn),   % AvVar is the list of variables of type Type
  ( select(Def,SymsIn,RestSyms) ->
    % if the entry (Type,AvVar) exists, add Var to AvVar
    ( append(AvVarsIn,[Var],AvVarsOut)     )
  ; % else introduce the pair (Type,[Var])
    ( RestSyms=SymsIn, AvVarsOut=[Var] )
  ),
  % update the the number that should be given to the next variable
  NumIdxOut=numbervars_index(M),
  % update the list of variables of Type
  SymsOut=[(Type,AvVarsOut)|RestSyms].

% SEMANTICS: write SMT-LIBv2 rules
write_muz3_rules([]).
%
write_muz3_rules([Rule|Rules]) :-
  write('(rule '), nl,
  write_smt_rule(Rule), nl,
  write(')'),      nl,
  write_muz3_rules(Rules).

% SEMANTICS: write symbol table
write_vars_declarations([]).
%
write_vars_declarations([(Type,Defs)|Vars]) :-
  write_vars_declarations_(Defs,Type),
  write_vars_declarations(Vars).

% SEMANTICS: write SMT-LIBv2 declarations of variables
write_vars_declarations_([],_Type) :-
  nl.
%
write_vars_declarations_([Var|Vars],Type) :-
  write('(declare-var '),
  write_stm_var(Var,Type),
  write(')'), nl,
  write_vars_declarations_(Vars,Type).

% MODE: first_upper(X,Y)
% SEMANTICS: convert the first element of the character list representing X
% to uppercase
first_upper(X,Y) :-
  atom_codes(X,L1),
  L1=[H1|T],
  H1>=97, H1=<122, H2 is H1-32,
  L2=[H2|T],
  atom_codes(Y,L2).

first_upper_chars(X,L2) :-
  atom_codes(X,L1),
  L1=[H1|T],
  H1>=97, H1=<122, H2 is H1-32,
  L2=[H2|T].
